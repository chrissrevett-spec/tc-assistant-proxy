<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talking Care Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; scrollbar-color: #ccc #FAFAFA; scrollbar-width: thin; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 10px; }
    html::-webkit-scrollbar-track, body::-webkit-scrollbar-track { background: #FAFAFA; }
    html::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { background: #ccc; border-radius: 8px; }
    html:hover::-webkit-scrollbar-thumb, body:hover::-webkit-scrollbar-thumb { background: #b3b3b3; }

    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0; padding: 0; background: #fff; color: #000;
      display: flex; flex-direction: column; min-height: 100dvh;
    }

    /* Shell constrains width; natural document flow (no sticky/footer behaviour) */
    .shell { width: 100%; max-width: 980px; margin: 0 auto; flex: 1 1 auto; display: flex; flex-direction: column; }

    /* Header */
    .wrap { padding: 16px 16px 8px; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { margin: 0; font-size: 14px; color: #000; opacity: .9; }
    #status { font-size: 12px; color: #555; min-height: 18px; margin-top: 6px; }

    /* Input bar sits right below header on load, and below chat after first message */
    .inputbar {
      background: #fff;
      padding: 8px 16px 12px;
      border-top: 1px solid #f0f0f0;
      border-bottom: 1px solid #f0f0f0;
      order: 2;            /* directly after header initially */
    }
    .inputrow { display: flex; gap: 8px; align-items: flex-start; flex-wrap: wrap; }
    .sr { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }

    textarea {
      flex: 1; min-height: 48px; max-height: 160px; resize: vertical;
      padding: 10px; font: inherit; background: #FAFAFA; color: #000;
      border: 1px solid #ddd; border-radius: 10px; transition: background .2s, border-color .2s, box-shadow .2s;
      scrollbar-width: thin; scrollbar-color: #ccc #FAFAFA; box-sizing: border-box;
    }
    textarea:focus { background: #f7f7f7; border-color: #ccc; outline: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.04); }

    button {
      padding: 10px 14px; cursor: pointer; border-radius: 10px; border: 1px solid #ddd;
      background: #FAFAFA; color: #333; transition: background .2s, color .2s, border-color .2s, box-shadow .2s;
      white-space: nowrap;
    }
    button:hover { background: #f0f0f0; border-color: #ccc; }
    button.secondary { background: #FAFAFA; color: #333; border-color: #ddd; }

    /* Attach chips */
    .chips { display: flex; gap: 6px; flex-wrap: wrap; margin: 6px 0 0; }
    .chip {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px;
      border: 1px solid #ddd; background: #FAFAFA;
    }
    .chip .x { cursor: pointer; border: none; background: transparent; font-size: 12px; line-height: 1; }

    /* Chat: hidden initially; shown between header and input after first send */
    .chat-wrap { display: none; }
    .chat {
      border: 1px solid #eee; background: #fff; border-radius: 12px;
      padding: 12px; /* no overflow; grows with content */
      box-shadow: 0 0 0 1px rgba(0,0,0,.03), 0 12px 24px rgba(0,0,0,.06);
      margin: 12px 16px 0; /* small spacing above; NO bottom margin = no gap above input */
    }

    /* When chat becomes active, it slots between header and input; input moves below it */
    .chat-active .chat-wrap { display: block; order: 2; }
    .chat-active .inputbar { order: 3; border-top: none; } /* remove double rule between chat and input */

    /* Messages */
    .msg { display: flex; gap: 10px; margin: 10px 0; align-items: flex-start; }
    .msg.assistant { flex-direction: row; }
    .msg.user { flex-direction: row-reverse; }

    .avatar {
      flex: 0 0 32px; height: 32px; width: 32px; border-radius: 50%;
      display: grid; place-items: center; background: #FAFAFA; border: 1px solid #eee;
      font-size: 18px; line-height: 1;
    }

    .bubble {
      max-width: 80%;
      background: #FAFAFA; color: #000;
      border: 1px solid #eee; border-radius: 14px;
      padding: 10px 12px; position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      overflow: hidden;
    }
    .msg.user .bubble { background: #FFF; border-color: #ddd; }

    .bubble-head {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
      font-weight: 600; font-size: 13px; color: #111;
    }

    .bubble-actions { margin-left: auto; display: flex; gap: 6px; }
    .copy-btn {
      border: 1px solid #ddd; background: #FAFAFA; color: #333; border-radius: 6px;
      font-size: 12px; padding: 2px 6px; cursor: pointer;
    }
    .copy-btn:hover { background: #f0f0f0; }

    .bubble-content { font-size: 14px; line-height: 1.5; }
    .bubble-content p { margin: 0 0 8px; }
    .bubble-content code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f5f5f5; padding: 1px 4px; border-radius: 4px; border: 1px solid #eee; }
    .bubble-content pre { background: #f5f5f5; padding: 8px; border-radius: 8px; overflow-x: auto; border: 1px solid #eee; }
    .bubble-content h1, .bubble-content h2, .bubble-content h3 { margin: 12px 0 6px; }
    .bubble-content ul, .bubble-content ol { margin: 8px 0 8px 20px; }
    .bubble-content blockquote { margin: 8px 0; padding: 8px 12px; background: #f7f7f7; border-left: 3px solid #ddd; border-radius: 6px; }

    .bubble-content table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px; }
    .bubble-content th, .bubble-content td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; vertical-align: top; }
    .bubble-content th { background: #f7f7f7; }
    .bubble-content tr:nth-child(even) td { background: #fcfcfc; }

    .sources { margin-top: 10px; padding-top: 8px; border-top: 1px dashed #e5e5e5; font-size: 13px; color: #444; }
    .sources .title { font-weight: 600; margin-bottom: 6px; }
  </style>
</head>
<body>
  <div class="shell" id="shell">
    <!-- Header -->
    <div class="wrap">
      <h1>Talking Care Navigator</h1>
      <p class="sub">Ask me anything about adult social care in England, including CQC registrations, regulations and guidance, Mental Capacity Act and DoLS queries, best practice advice, auditing, policy queries and more. Always consult your organisations' confidentiality policy.</p>
      <div id="status"></div>
    </div>

    <!-- Input directly under header on load -->
    <div class="inputbar" id="inputbar">
      <div class="inputrow">
        <label for="tc-input" class="sr">Message</label>
        <textarea id="tc-input" placeholder="Type your question‚Ä¶ üôÇ"></textarea>
        <button id="tc-attach" type="button" title="Attach file">üìé Attach</button>
        <input id="file-input" type="file" hidden multiple />
        <button id="tc-ask-stream" title="Send">‚úàÔ∏è Send</button>
        <button id="tc-clear" class="secondary" title="Clear chat">Clear</button>
        <div id="chips" class="chips" aria-live="polite"></div>
      </div>
    </div>

    <!-- Chat appears between header and input after first message -->
    <div class="chat-wrap" id="chatwrap">
      <div id="chat" class="chat" aria-live="polite" aria-busy="false"></div>
    </div>
  </div>

  <!-- Force page load to start at top (Option A snippet) -->
  <script>
    if ('scrollRestoration' in history) { history.scrollRestoration = 'manual'; }
    window.addEventListener('DOMContentLoaded', () => {
      window.scrollTo(0, 0);
      setTimeout(() => window.scrollTo(0, 0), 0);
    });
    window.addEventListener('pageshow', (e) => { if (e.persisted) window.scrollTo(0, 0); });
  </script>

  <!-- Markdown parser (ESM) + DOMPurify -->
  <script type="module">
    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    const purifyUrl = "https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js";
    await import(purifyUrl);

    // Elements
    const API_BASE = location.origin.replace(/\/$/, "");
    const $shell   = document.getElementById("shell");
    const $chat    = document.getElementById("chat");
    const $chatwrap= document.getElementById("chatwrap");
    const $inputbar= document.getElementById("inputbar");
    const $in      = document.getElementById("tc-input");
    const $send    = document.getElementById("tc-ask-stream");
    const $clear   = document.getElementById("tc-clear");
    const $status  = document.getElementById("status");
    const $attach  = document.getElementById("tc-attach");
    const $fileIn  = document.getElementById("file-input");
    const $chips   = document.getElementById("chips");

    marked.setOptions({ mangle: false, headerIds: false });

    function setStatus(t) { $status.textContent = t || ""; $chat.setAttribute("aria-busy", t ? "true" : "false"); }

    // ---- Conversation history (client side) ----
    const history = (() => { try { return JSON.parse(sessionStorage.getItem("tc_history") || "[]"); } catch { return []; } })();
    function saveHistory() { try { sessionStorage.setItem("tc_history", JSON.stringify(history)); } catch {} }
    function clearHistory() { history.length = 0; saveHistory(); }

    // ---- File attachments (client side state) ----
    // status: "pending" | "uploading" | "ready" | "error"
    const filesState = []; // { name, id?, status, size? }

    function renderChips() {
      $chips.innerHTML = "";
      for (const f of filesState) {
        const chip = document.createElement("span");
        chip.className = "chip";
        let icon = "‚è≥";
        if (f.status === "ready") icon = "‚úÖ";
        else if (f.status === "error") icon = "‚ö†Ô∏è";
        else if (f.status === "uploading") icon = "‚è´";
        chip.textContent = `${icon} ${f.name}`;
        const x = document.createElement("button");
        x.className = "x";
        x.setAttribute("aria-label", `Remove ${f.name}`);
        x.textContent = "‚úñ";
        x.onclick = () => {
          const i = filesState.indexOf(f);
          if (i >= 0) filesState.splice(i, 1);
          renderChips();
        };
        chip.appendChild(x);
        $chips.appendChild(chip);
      }
    }
    function uploadsReady() { return filesState.every(f => f.status === "ready"); }

    async function uploadOne(file) {
      const entry = { name: file.name, status: "pending", size: file.size };
      filesState.push(entry);
      renderChips();
      entry.status = "uploading"; renderChips();

      const fd = new FormData();
      fd.append("file", file);

      try {
        const r = await fetch(`${API_BASE}/api/upload`, { method: "POST", body: fd });
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const j = await r.json();
        if (!j?.file?.id) throw new Error("No file id in response");
        entry.id = j.file.id;
        entry.status = "ready";
      } catch (e) {
        entry.status = "error";
        console.error("upload failed:", e);
        setStatus(`File upload failed for ${file.name}`);
      }
      renderChips();
    }

    // Ensure chat is visible between header and input (no sticky)
    function activateChat() {
      if (!$shell.classList.contains("chat-active")) {
        $shell.classList.add("chat-active");
      }
    }

    // Create a message bubble
    function createMsg(role, headerText, withCopy = false) {
      const msg = document.createElement("div");
      msg.className = `msg ${role}`;
      const avatar = document.createElement("div");
      avatar.className = "avatar";
      avatar.textContent = role === "assistant" ? "üìñ" : "üôÇ";

      const bubble = document.createElement("div");
      bubble.className = "bubble";

      const head = document.createElement("div");
      head.className = "bubble-head";
      head.textContent = headerText;

      if (withCopy) {
        const actions = document.createElement("div");
        actions.className = "bubble-actions";
        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn";
        copyBtn.type = "button";
        copyBtn.title = "Copy";
        copyBtn.textContent = "üìã Copy";
        const content = document.createElement("div"); // placeholder; reassigned below
        copyBtn.addEventListener("click", () => {
          const txt = bubble.querySelector(".bubble-content")?.innerText?.trim() || "";
          navigator.clipboard.writeText(txt).then(() => {
            copyBtn.textContent = "‚úÖ Copied";
            setTimeout(() => (copyBtn.textContent = "üìã Copy"), 1200);
          });
        });
        actions.appendChild(copyBtn);
        head.appendChild(actions);
      }

      const content = document.createElement("div");
      content.className = "bubble-content";

      bubble.appendChild(head);
      bubble.appendChild(content);

      msg.appendChild(avatar);
      msg.appendChild(bubble);
      $chat.appendChild(msg);

      // Keep input visually immediately below latest message
      $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });

      return { msg, content, bubble };
    }

    // Render markdown safely
    function renderMarkdown(md, el) {
      const html = marked.parse(md || "");
      const safe = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
      el.innerHTML = safe;
      // Keep input close after content changes
      $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
    }

    // Append Sources (at end, once)
    function appendSources(containerEl, citations) {
      if (!citations || citations.length === 0) return;
      const seenFile = new Set(), seenURL = new Set();
      const files = [], urls = [];
      for (const c of citations) {
        if (c.kind === "file") { if (!seenFile.has(c.id)) { seenFile.add(c.id); files.push(c); } }
        if (c.kind === "web")  { if (!seenURL.has(c.url)) { seenURL.add(c.url); urls.push(c); } }
      }
      if (!files.length && !urls.length) return;

      const src = document.createElement("div");
      src.className = "sources";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = "Sources:";
      src.appendChild(title);

      const list = document.createElement("ul");
      list.style.margin = "0";
      list.style.paddingLeft = "20px";
      [...files, ...urls].forEach((c) => {
        const li = document.createElement("li");
        li.textContent = c.label;
        list.appendChild(li);
      });

      src.appendChild(list);
      containerEl.appendChild(src);
      $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
    }

    let currentAbort = null;

    // SSE streaming
    async function askStream(prompt) {
      activateChat();

      // Push latest user turn to local history before request
      history.push({ role: "user", content: prompt });
      saveHistory();

      // User bubble
      createMsg("user", "You").content.textContent = prompt;

      // Assistant bubble
      const { content: aContent } = createMsg("assistant", "Talking Care Navigator", true);
      aContent.innerHTML = `<em>Thinking‚Ä¶ ‚è≥</em>`;

      // State
      let buffer = "";
      let started = false;
      let firstDeltaSeen = false;
      let mdAccum = "";
      const citations = [];
      let sourcesAppended = false;
      let assistantTurnSaved = false;

      setStatus("Thinking‚Ä¶ ‚è≥");
      const ac = new AbortController();
      currentAbort = ac;

      // Block send if uploads pending
      if (filesState.some(f => f.status === "uploading" || f.status === "pending")) {
        setStatus("Please wait for file uploads to finish ‚è≥");
        return;
      }

      // Collect ready file IDs
      const fileIds = filesState.filter(f => f.status === "ready" && f.id).map(f => f.id);

      // Watchdog for CORS/no-stream
      const watchdog = setTimeout(() => {
        if (!started) {
          aContent.innerHTML = `<span>‚ö†Ô∏è No stream started ‚Äî check CORS settings on the server.</span>`;
          setStatus("");
        }
      }, 10000);

      // Fetch SSE with rolling history + attachments
      let r;
      try {
        r = await fetch(`${API_BASE}/api/assistant?stream=on`, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "text/event-stream" },
          body: JSON.stringify({ userMessage: prompt, history, fileIds }),
          signal: ac.signal
        });
      } catch (e) {
        clearTimeout(watchdog);
        aContent.innerHTML = `<span>‚ö†Ô∏è Request failed: ${e?.message || e}</span>`;
        setStatus("");
        currentAbort = null;
        return;
      }

      if (!r.ok || !r.body) {
        clearTimeout(watchdog);
        let err = `HTTP ${r.status}`;
        try { err += ` ${await r.text()}`; } catch {}
        aContent.innerHTML = `<span>‚ö†Ô∏è Stream failed: ${err}</span>`;
        setStatus("");
        currentAbort = null;
        return;
      }

      // Request accepted: clear attached files UI so we don't re-send them by accident
      if (filesState.length) {
        filesState.length = 0;
        renderChips();
      }

      const reader = r.body.getReader();
      const decoder = new TextDecoder("utf-8");

      const flushBlocks = (chunk) => {
        buffer += chunk;
        const blocks = buffer.split(/\n\n/);
        buffer = blocks.pop();
        for (const block of blocks) {
          const lines = block.split(/\n/);
          let event = "message";
          const dataLines = [];
          for (const line of lines) {
            if (!line) continue;
            if (line.startsWith(":")) continue;
            if (line.startsWith("event:")) { event = line.slice(6).trim(); continue; }
            if (line.startsWith("data:"))  { dataLines.push(line.slice(5).trim()); continue; }
          }
          const raw = dataLines.join("\n");
          handleEvent(event, raw);
        }
      };

      function handleEvent(event, raw) {
        if (event === "start") { return; }

        if (event === "error") {
          try {
            const obj = JSON.parse(raw);
            aContent.innerHTML = `<span>‚ö†Ô∏è ${escapeHtml(JSON.stringify(obj))}</span>`;
          } catch {
            aContent.innerHTML = `<span>‚ö†Ô∏è ${escapeHtml(raw)}</span>`;
          }
          setStatus("");
          return;
        }

        if (event === "done" || event === "response.completed") {
          setStatus("");

          if (!sourcesAppended) {
            appendSources(aContent, citations);
            sourcesAppended = true;
          }

          if (!assistantTurnSaved) {
            const finalText = stripInlineSources(mdAccum).trim();
            if (finalText) {
              history.push({ role: "assistant", content: finalText });
              saveHistory();
            }
            assistantTurnSaved = true;
          }
          return;
        }

        if (event.endsWith(".delta")) {
          let d;
          try { d = JSON.parse(raw); } catch { d = null; }
          const deltaText =
            (d && typeof d.delta === "string") ? d.delta :
            (d && d.delta && Array.isArray(d.delta.content))
              ? d.delta.content.map(c => (c.text && (c.type?.includes("output_text"))) ? c.text : "").join("")
              : (typeof d?.text_delta === "string" ? d.text_delta : "");

          if (deltaText) {
            if (!firstDeltaSeen) { firstDeltaSeen = true; setStatus(""); }
            const cleaned = sanitizeBodyDelta(deltaText);
            mdAccum += cleaned;
            renderMarkdown(mdAccum, aContent);
          }
          return;
        }

        if (event.includes("annotation") || event.includes("citation")) {
          let a;
          try {
            const obj = JSON.parse(raw);
            a = obj?.annotation || obj?.data || obj;
          } catch { a = null; }
          if (!a) return;
          if (a.type === "file_citation" && a.file_id) {
            citations.push({ kind: "file", id: a.file_id, label: a.filename || a.file_id });
          } else if ((a.type === "web_citation" || a.url) && a.url) {
            citations.push({ kind: "web", url: a.url, label: a.title || a.url });
          }
        }
      }

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          if (chunk && !started) { started = true; clearTimeout(watchdog); }
          flushBlocks(chunk);
        }
      } catch (e) {
        aContent.insertAdjacentHTML("beforeend", `<p>‚ö†Ô∏è Stream error: ${escapeHtml(e?.message || String(e))}</p>`);
      } finally {
        currentAbort = null;
        setStatus("");
      }
    }

    function sanitizeBodyDelta(s) {
      if (!s) return s;
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, "$1");   // remove inline markdown links
      s = s.replace(/https?:\/\/\S+/g, "");                          // remove raw URLs
      s = s.replace(/\s?\[\d+\]/g, "");                              // remove [1] style refs
      s = s.replace(/\n?^\s*Sources?:[\s\S]*$/im, "");               // remove inline Sources sections
      return s;
    }
    function stripInlineSources(s) {
      if (!s) return s;
      return s.replace(/\n?^\s*Sources?:[\s\S]*$/im, "");
    }
    function escapeHtml(str) {
      return (str || "").replace(/[&<>"']/g, (ch) => ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;" }[ch]));
    }

    // Events
    $attach.addEventListener("click", () => $fileIn.click());
    $fileIn.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      setStatus("Uploading file(s)‚Ä¶");
      for (const f of files) await uploadOne(f);
      setStatus("");
      $fileIn.value = ""; // allow selecting same file again
    });

    $send.addEventListener("click", () => {
      const p = ($in.value || "").trim();
      if (!p) return;
      if (filesState.some(f => f.status === "uploading" || f.status === "pending")) {
        setStatus("Please wait for file uploads to finish ‚è≥");
        return;
      }
      askStream(p);
      $in.value = "";
    });

    $in.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        $send.click();
      }
    });

    $clear.addEventListener("click", () => {
      if (currentAbort) { try { currentAbort.abort(); } catch {} currentAbort = null; }
      $chat.innerHTML = "";
      $in.value = "";
      filesState.length = 0; renderChips();
      setStatus("");
      clearHistory();
      // Return to pre-chat layout (input right under header, chat hidden)
      document.getElementById("shell").classList.remove("chat-active");
    });
  </script>
</body>
</html>
