<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talking Care Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0c10; --card:#14161a; --muted:#8892a6; --text:#e6edf3; --accent:#6aa3ff; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:var(--bg); color:var(--text);
    }
    .wrap{max-width:980px;margin:0 auto;padding:16px}
    .panel{background:var(--card);border:1px solid #23262d;border-radius:14px;overflow:hidden}
    .row{display:flex;gap:8px;align-items:stretch}
    .col{flex:1}
    textarea{
      width:100%; height:120px; resize:vertical; padding:12px 12px;
      background:#0f1115; color:var(--text); border:1px solid #22262c; border-radius:10px; outline:none;
    }
    button{
      background:var(--accent); color:#06122e; font-weight:700; border:0; border-radius:10px; padding:12px 16px; cursor:pointer;
    }
    button.secondary{ background:#273246; color:#c9d7ee }
    .out{
      min-height:280px; white-space:pre-wrap; padding:16px; line-height:1.5;
      border-top:1px solid #23262d; background:#0e1116; font-size:15px;
    }
    .bar{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid #23262d}
    .status{color:var(--muted);font-size:13px}
    .tiny{font-size:12px;color:#9aa7bd}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="bar">
        <div><strong>Talking Care Navigator</strong> <span class="tiny">— beta</span></div>
        <div class="status" id="tc-status"></div>
      </div>

      <div style="padding:16px">
        <div class="row" style="margin-bottom:8px">
          <div class="col">
            <textarea id="tc-input" placeholder="Ask a question for a Registered Manager in adult social care…"></textarea>
          </div>
        </div>
        <div class="row" style="margin-bottom:8px">
          <button id="tc-ask-stream">Ask (Streaming)</button>
          <button id="tc-ask-nonstream" class="secondary">Ask (Non-streaming)</button>
          <button id="tc-clear" class="secondary">Clear</button>
        </div>
      </div>

      <div class="out" id="tc-output"></div>
    </div>
  </div>

  <script>
    // --- CONFIG ---------------------------------------------------------------
    const API_BASE = location.origin; // widget is served from tc-assistant-proxy.vercel.app
    // If you serve widget.html elsewhere, hardcode: const API_BASE = "https://tc-assistant-proxy.vercel.app";

    // --- ELEMENTS -------------------------------------------------------------
    const $status = document.getElementById("tc-status");
    const $input  = document.getElementById("tc-input");
    const $out    = document.getElementById("tc-output");
    const $btnS   = document.getElementById("tc-ask-stream");
    const $btnN   = document.getElementById("tc-ask-nonstream");
    const $btnC   = document.getElementById("tc-clear");

    // Persist one thread id inside this iframe (no CORS headaches)
    let currentThreadId = null;

    function setStatus(s){ $status.textContent = s || ""; }
    function write(t){ $out.textContent += t; }
    function writeln(t=""){ $out.textContent += t + "\n"; }
    function clear(){ $out.textContent = ""; }

    // --- NON-STREAMING --------------------------------------------------------
    async function askNonStreaming(prompt){
      setStatus("Thinking…");
      const r = await fetch(`${API_BASE}/api/assistant?stream=off`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userMessage: prompt, threadId: currentThreadId })
      });
      setStatus("");
      if(!r.ok){ writeln(`⚠️ HTTP ${r.status}`); return; }
      const data = await r.json().catch(()=> ({}));
      if (data?.thread_id) currentThreadId = data.thread_id;
      if (data?.ok && data?.text){
        writeln(data.text);
      } else {
        writeln("⚠️ No response.");
      }
    }

    // --- STREAMING (SSE over fetch POST) -------------------------------------
    async function askStreaming(prompt){
      setStatus("Typing…");
      const resp = await fetch(`${API_BASE}/api/assistant?stream=on`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userMessage: prompt, threadId: currentThreadId })
      });
      if (!resp.ok || !resp.body){ setStatus(""); writeln(`⚠️ Stream failed (${resp.status}).`); return; }

      const reader  = resp.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buf = "";

      const flushBlocks = (raw) => {
        buf += raw;
        const blocks = buf.split(/\n\n/);
        buf = blocks.pop(); // keep incomplete tail
        for (const block of blocks){
          const lines = block.split(/\n/);
          let event = "message";
          const datas = [];
          for (const line of lines){
            if (line.startsWith(":")) continue;                 // comment/keep-alive
            if (line.startsWith("event:")) { event = line.slice(6).trim(); continue; }
            if (line.startsWith("data:"))  { datas.push(line.slice(5).trim()); continue; }
          }
          const payload = datas.join("\n");
          handleSSE(event, payload);
        }
      };

      function safeAppendText(val){
        // Handle strings or nested deltas robustly; avoid [object Object]
        if (typeof val === "string"){ write(val); return; }
        if (val && typeof val === "object"){
          // Known shapes:
          // { delta: { type:"output_text_delta", text:"..." } }
          if (val.delta?.text && typeof val.delta.text === "string"){
            write(val.delta.text);
            return;
          }
          // { delta:{ content:[{type:"output_text_delta", text:"..."}] } }
          const arr = val.delta?.content;
          if (Array.isArray(arr)){
            for (const c of arr){
              if (c && typeof c.text === "string") write(c.text);
            }
            return;
          }
          // Fallback: try a few common property names
          if (typeof val.text === "string"){ write(val.text); return; }
        }
        // If completely unknown, ignore to avoid “[object Object]”
      }

      function handleSSE(event, rawData){
        if (event === "start"){
          try {
            const d = JSON.parse(rawData);
            if (d?.thread_id) currentThreadId = d.thread_id;
          } catch {}
          return;
        }
        if (event === "error"){
          setStatus("");
          try { writeln(`⚠️ ${rawData}`); } catch { writeln("⚠️ Stream error"); }
          return;
        }
        if (event === "done" || event === "response.completed" || event === "thread.message.completed"){
          setStatus(""); writeln(); return;
        }

        // Echo test path (your /api/echo?mode=stream)
        if (event === "response.output_text.delta"){
          try {
            const d = JSON.parse(rawData);
            safeAppendText(d);
          } catch {}
          return;
        }

        // Real Assistants v2 streaming paths
        if (event === "thread.message.delta" || event === "response.output_text.delta" || event === "response.refusal.delta"){
          try {
            const d = JSON.parse(rawData);
            safeAppendText(d);
          } catch {}
          return;
        }

        // Ignore tool events etc.
      }

      try{
        while(true){
          const {value, done} = await reader.read();
          if (done) break;
          flushBlocks(decoder.decode(value, { stream:true }));
        }
      }catch{} finally{
        setStatus("");
      }
    }

    // --- UI BINDINGS ----------------------------------------------------------
    $btnS.addEventListener("click", () => {
      const prompt = ($input.value || "").trim();
      if (!prompt) return;
      clear(); askStreaming(prompt);
    });

    $btnN.addEventListener("click", () => {
      const prompt = ($input.value || "").trim();
      if (!prompt) return;
      clear(); askNonStreaming(prompt);
    });

    $btnC.addEventListener("click", () => { clear(); setStatus(""); });

    // Optional: expose for console quick tests
    window.tcAskS = askStreaming;
    window.tcAskN = askNonStreaming;
  </script>
</body>
</html>
