<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talking Care Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; scrollbar-color: #ccc #FAFAFA; scrollbar-width: thin; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 10px; }
    html::-webkit-scrollbar-track, body::-webkit-scrollbar-track { background: #FAFAFA; }
    html::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { background: #ccc; border-radius: 8px; }
    html:hover::-webkit-scrollbar-thumb, body:hover::-webkit-scrollbar-thumb { background: #b3b3b3; }

    html, body { height: 100%; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; background: #fff; }

    .shell { width: 100%; max-width: none; min-height: 100dvh; margin: 0; border-radius: 16px; background: #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,.06), 0 12px 24px rgba(0,0,0,.06), 0 0 0 20px #F5F5F5; box-sizing: border-box; display: flex; flex-direction: column; }
    .wrap { border-radius: 16px; padding: 16px; background: #fff; flex: 1; display: flex; flex-direction: column; }

    h1 { margin: 0 0 4px; font-size: 22px; color: #000; }
    .sub { margin: 0 0 12px; font-size: 14px; color: #000; }
    #status { font-size: 12px; opacity: .8; margin-bottom: 8px; }

    .row { display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
    .row > textarea { flex: 1 1 420px; }
    .row > .btns { display:flex; flex-direction:column; gap:8px; }

    textarea {
      min-height: 112px; padding: 10px; font: inherit; background: #FAFAFA; color: #000;
      border: 1px solid #ddd; border-radius: 8px; transition: background .2s, border-color .2s, box-shadow .2s;
      scrollbar-width: thin; scrollbar-color: #ccc #FAFAFA; box-sizing: border-box;
    }
    textarea::placeholder { color: #777; }
    textarea:hover { background: #f7f7f7; border-color: #ccc; }
    textarea:focus { background: #f7f7f7; border-color: #ccc; outline: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.04); }

    button {
      padding: 10px 14px; cursor: pointer; border-radius: 8px; border: 1px solid #ddd;
      background: #FAFAFA; color: #333; transition: background .2s, color .2s, border-color .2s, box-shadow .2s;
    }
    button:hover { background: #f0f0f0; border-color: #ccc; }
    button:active { background: #e9e9e9; border-color: #c9c9c9; box-shadow: inset 0 1px 2px rgba(0,0,0,0.06); }
    button.secondary { background: #FAFAFA; color: #333; border-color: #ddd; }

    #out {
      position: relative; white-space: pre-wrap; border: 1px solid #FAFAFA; border-radius: 8px;
      padding: 12px; min-height: 160px; background: #FAFAFA; color: #000; overflow-y: auto;
      transition: background .2s, border-color .2s, box-shadow .2s; scrollbar-width: thin; scrollbar-color: #ccc #FAFAFA;
      box-sizing: border-box; flex: 1 1 auto;
    }
    #out:hover { background: #f7f7f7; border-color: #ccc; }
    #out:empty::before { content: "I'll respond to your question here"; color: #777; }

    #out::-webkit-scrollbar, textarea::-webkit-scrollbar { width: 10px; }
    #out::-webkit-scrollbar-track, textarea::-webkit-scrollbar-track { background: #FAFAFA; border-radius: 8px; }
    #out::-webkit-scrollbar-thumb, textarea::-webkit-scrollbar-thumb { background: #ccc; border-radius: 8px; }
    #out:hover::-webkit-scrollbar-thumb, textarea:hover::-webkit-scrollbar-thumb { background: #b3b3b3; }

    #log { display: none; }
  </style>
</head>
<body>
  <div class="shell">
    <div class="wrap">
      <h1>Talking Care Navigator</h1>
      <p class="sub">
        Ask me anything about adult social care in England, including CQC registrations, regulations and guidance, Mental Capacity Act and DoLS queries, best practice advice, case management and more.
      </p>

      <div id="status"></div>

      <div class="row">
        <textarea id="tc-input" placeholder="How can I help?"></textarea>
        <div class="btns">
          <button id="tc-ask-stream">Submit</button>
          <button id="tc-clear" class="secondary">Clear chat</button>
        </div>
      </div>

      <div id="out"></div>
      <div id="log"></div>
    </div>
  </div>

  <script>
  document.addEventListener("DOMContentLoaded", () => {
    const API_BASE = location.origin.replace(/\/$/, "");
    const $in   = document.getElementById("tc-input");
    const $out  = document.getElementById("out");
    const $stat = document.getElementById("status");
    const $btnS = document.getElementById("tc-ask-stream");
    const $btnC = document.getElementById("tc-clear");
    const $log  = document.getElementById("log");

    function log(...a){ $log.textContent += a.map(v => typeof v === "string" ? v : JSON.stringify(v)).join(" ") + "\n"; }
    function setStatus(t){ $stat.textContent = t || ""; }
    function append(t){ $out.textContent += t; $out.scrollTop = $out.scrollHeight; }
    function nl(){ append("\n"); }
    function clearOut(){ $out.textContent = ""; }

    log(`✅ widget ready. API_BASE = ${API_BASE}`);

    function getPrompt() {
      const p = ($in.value || "").trim();
      return p || null;
    }

    let currentAbort = null;

    async function askStream(prompt) {
      setStatus("Thinking…");
      clearOut();
      citations.length = 0;
      answerBuf = "";
      firstDeltaSeen = false;

      const ac = new AbortController();
      currentAbort = ac;

      let started = false;
      let watchdog = setTimeout(() => {
        if (!started) {
          append("⚠️ No stream started — likely CORS. Check that your page origin is in CORS_ALLOWLIST on the server.\n");
          setStatus("");
        }
      }, 10000);

      let r;
      try {
        r = await fetch(`${API_BASE}/api/assistant?stream=on`, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "text/event-stream" },
          body: JSON.stringify({ userMessage: prompt }),
          signal: ac.signal
        });
      } catch (e) {
        clearTimeout(watchdog);
        setStatus("");
        append(`⚠️ Request blocked or failed: ${e?.message || e}\n`);
        log("fetch error", e);
        currentAbort = null;
        return;
      }

      if (!r.ok || !r.body) {
        clearTimeout(watchdog);
        setStatus("");
        let err = `HTTP ${r.status}`;
        try { err += ` ${await r.text()}`; } catch {}
        append(`⚠️ Stream failed: ${err}\n`);
        currentAbort = null;
        return;
      }

      const reader  = r.body.getReader();
      const decoder = new TextDecoder("utf-8");
      buffer = "";

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          if (chunk && !started) { started = true; clearTimeout(watchdog); }
          flushBlocks(chunk);
        }
      } catch (e) {
        append(`\n⚠️ Stream error: ${e?.message || e}\n`);
      } finally {
        currentAbort = null;
        setStatus("");
      }
    }

    // ===== SSE parsing state =====
    let buffer = "";
    const citations = []; // { kind: "file"|"web", label, id?, url? }
    let answerBuf = "";
    let firstDeltaSeen = false;

    function normalizeEvent(eventName, raw) {
      let obj = null;
      try { obj = JSON.parse(raw); } catch {}
      if (eventName === "message" && obj && typeof obj.event === "string") {
        return { eventName: obj.event, dataObj: obj.data ?? obj };
      }
      return { eventName, dataObj: obj ?? { raw } };
    }

    function extractTextDelta(d) {
      if (d && typeof d.delta === "string") return d.delta;
      if (d && d.delta && Array.isArray(d.delta.content)) {
        let out = "";
        for (const c of d.delta.content) {
          if ((c.type && c.type.includes("output_text")) && typeof c.text === "string") out += c.text;
        }
        if (out) return out;
      }
      if (typeof d?.text_delta === "string") return d.text_delta;
      return "";
    }

    function sanitizeBodyDelta(s) {
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, "$1");
      s = s.replace(/https?:\/\/\S+/g, "");
      s = s.replace(/\s?\[\d+\]/g, "");
      s = s.replace(/\s?\((?:source|Source):\s*[^)]+\)/g, "");
      s = s.replace(/\n?^\s*Sources?:[\s\S]*$/im, "");
      return s;
    }

    function flushBlocks(chunk) {
      buffer += chunk;
      const blocks = buffer.split(/\n\n/);
      buffer = blocks.pop();
      for (const block of blocks) {
        const lines = block.split(/\n/);
        let event = "message";
        const dataLines = [];
        for (const line of lines) {
          if (!line) continue;
          if (line.startsWith(":")) continue;
          if (line.startsWith("event:")) { event = line.slice(6).trim(); continue; }
          if (line.startsWith("data:"))  { dataLines.push(line.slice(5).trim()); continue; }
        }
        const raw = dataLines.join("\n");
        const { eventName, dataObj } = normalizeEvent(event, raw);
        handleEvent(eventName, dataObj);
      }
    }

    function handleEvent(event, dataObj) {
      if (event === "start") { return; }
      if (event === "error") { setStatus(""); append(`⚠️ ${JSON.stringify(dataObj)}\n`); return; }

      if (event === "done" || event === "response.completed") {
        setStatus("");
        const seenFile = new Set();
        const seenURL  = new Set();
        const files = [];
        const urls  = [];
        for (const c of citations) {
          if (c.kind === "file") { if (!seenFile.has(c.id)) { seenFile.add(c.id); files.push(c); } }
          else if (c.kind === "web") { if (!seenURL.has(c.url)) { seenURL.add(c.url); urls.push(c); } }
        }
        if (files.length || urls.length) {
          append("\n\nSources:\n");
          files.forEach(c => append(`• ${c.label}\n`));
          urls.forEach(c => append(`• ${c.label}\n`));
        }
        return;
      }

      if (event.endsWith(".delta")) {
        const deltaText = extractTextDelta(dataObj);
        if (deltaText) {
          if (!firstDeltaSeen) { firstDeltaSeen = true; setStatus(""); }
          const cleaned = sanitizeBodyDelta(deltaText);
          answerBuf += cleaned;
          append(cleaned);
        }
        return;
      }

      if (event.includes("annotation") || event.includes("citation")) {
        const a = dataObj?.annotation || dataObj?.data || dataObj;
        if (a?.type === "file_citation" && a.file_id) {
          citations.push({ kind: "file", id: a.file_id, label: a.filename || a.file_id });
        } else if ((a?.type === "web_citation" || a?.type === "url_citation" || a?.url) && a.url) {
          citations.push({ kind: "web", url: a.url, label: a.title || a.url });
        }
        return;
      }
    }

    $btnS.addEventListener("click", async () => {
      const p = getPrompt(); if (!p) return;
      await askStream(p);
    });

    $in.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        $btnS.click();
      }
    });

    $btnC.addEventListener("click", () => {
      if (currentAbort) { try { currentAbort.abort(); } catch {} currentAbort = null; }
      clearOut(); $in.value = ""; setStatus("");
      citations.length = 0; answerBuf = ""; firstDeltaSeen = false;
    });
  });
  </script>
</body>
</html>
