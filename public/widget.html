<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talking Care Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; scrollbar-color: #ccc #FAFAFA; scrollbar-width: thin; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 10px; }
    html::-webkit-scrollbar-track, body::-webkit-scrollbar-track { background: #FAFAFA; }
    html::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { background: #ccc; border-radius: 8px; }
    html:hover::-webkit-scrollbar-thumb, body:hover::-webkit-scrollbar-thumb { background: #b3b3b3; }

    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0; padding: 0; background: #fff; color: #000;
      display: flex; flex-direction: column; min-height: 100dvh;
    }

    .shell { width: 100%; max-width: 980px; margin: 0 auto; flex: 1 1 auto; display: flex; flex-direction: column; }

    .wrap { padding: 16px 16px 8px; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { margin: 0; font-size: 14px; color: #000; opacity: .9; }
    #status { font-size: 12px; color: #555; min-height: 18px; margin-top: 6px; }

    .inputbar {
      background: #fff;
      padding: 8px 16px 12px;
      border-top: 1px solid #f0f0f0;
      border-bottom: 1px solid #f0f0f0;
      order: 2;
    }

    /* Composer row ‚Äî by default single row; wraps under a small-screen breakpoint */
    .inputrow {
      display: flex; gap: 8px; align-items: flex-start; flex-wrap: nowrap;
    }

    .sr { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }

    textarea {
      flex: 1 1 auto; min-height: 48px; max-height: 160px; resize: vertical;
      padding: 10px; font: inherit; background: #FAFAFA; color: #000;
      border: 1px solid #ddd; border-radius: 10px; transition: background .2s, border-color .2s, box-shadow .2s;
      scrollbar-width: thin; scrollbar-color: #ccc #FAFAFA; box-sizing: border-box;
    }
    textarea:focus { background: #f7f7f7; border-color: #ccc; outline: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.04); }

    /* Unified primary buttons */
    .ui-btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 8px;
      height: 40px; padding: 0 14px; cursor: pointer; border-radius: 10px; border: 1px solid #ddd;
      background: #FAFAFA; color: #333; font-size: 14px; line-height: 1; letter-spacing: .2px;
      transition: background .2s, color .2s, border-color .2s, box-shadow .2s;
      white-space: nowrap; user-select: none;
      flex: 0 0 auto;
    }
    .ui-btn:hover { background: #f0f0f0; border-color: #ccc; }
    .ui-btn.secondary { background: #FAFAFA; color: #333; border-color: #ddd; }

    /* Small-screen wrapping behaviour: textarea full-width on line 1; buttons wrap to line 2 */
    @media (max-width: 540px) {
      .inputrow { flex-wrap: wrap; }
      .inputrow textarea { flex: 1 1 100%; width: 100%; }
      .inputrow .ui-btn { margin-top: 8px; }
    }

    /* Upload badge row (to avoid squashing textarea on long names) */
    .attach-row { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
    .attach-status {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #ddd; background: #FAFAFA;
      max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .attach-status .fname { max-width: 36ch; overflow: hidden; text-overflow: ellipsis; }
    .attach-status.ok { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .attach-status.pending { border-color: #ddd; background: #FAFAFA; color: #333; }
    .attach-status.error { border-color: #e57373; background: #fff5f5; color: #b71c1c; }
    .attach-status .icon { font-size: 14px; }

    /* Chat */
    .chat-wrap { display: none; }
    .chat {
      border: 1px solid #eee; background: #fff; border-radius: 12px;
      padding: 12px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.03), 0 12px 24px rgba(0,0,0,.06);
      margin: 12px 16px 0;
    }
    .chat-active .chat-wrap { display: block; order: 2; }
    .chat-active .inputbar { order: 3; border-top: none; }

    .msg { display: flex; gap: 10px; margin: 10px 0; align-items: flex-start; }
    .msg.assistant { flex-direction: row; }
    .msg.user { flex-direction: row-reverse; }

    .avatar {
      flex: 0 0 32px; height: 32px; width: 32px; border-radius: 50%;
      display: grid; place-items: center; background: #FAFAFA; border: 1px solid #eee;
      font-size: 18px; line-height: 1; overflow: hidden;
    }
    .avatar img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }

    .bubble {
      max-width: 80%;
      background: #FAFAFA; color: #000;
      border: 1px solid #eee; border-radius: 14px;
      padding: 10px 12px; position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      overflow: hidden;
    }
    .msg.user .bubble { background: #FFF; border-color: #ddd; }

    .bubble-head {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
      font-weight: 600; font-size: 13px; color: #111;
    }
    .bubble-actions { margin-left: auto; display: flex; gap: 6px; }
    .copy-btn {
      border: 1px solid #ddd; background: #FAFAFA; color: #333; border-radius: 6px;
      font-size: 12px; padding: 2px 6px; cursor: pointer;
    }
    .copy-btn:hover { background: #f0f0f0; }

    .bubble-content { font-size: 14px; line-height: 1.5; }
    .bubble-content p { margin: 0 0 8px; }
    .bubble-content code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f5f5f5; padding: 1px 4px; border-radius: 4px; border: 1px solid #eee; }
    .bubble-content pre { background: #f5f5f5; padding: 8px; border-radius: 8px; overflow-x: auto; border: 1px solid #eee; }
    .bubble-content h1, .bubble-content h2, .bubble-content h3 { margin: 12px 0 6px; }
    .bubble-content ul, .bubble-content ol { margin: 8px 0 8px 20px; }
    .bubble-content blockquote { margin: 8px 0; padding: 8px 12px; background: #f7f7f7; border-left: 3px solid #ddd; border-radius: 6px; }

    .bubble-content table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px; }
    .bubble-content th, .bubble-content td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; vertical-align: top; }
    .bubble-content th { background: #f7f7f7; }
    .bubble-content tr:nth-child(even) td { background: #fcfcfc; }

    .sources { margin-top: 10px; padding-top: 8px; border-top: 1px dashed #e5e5e5; font-size: 13px; color: #444; }
    .sources .title { font-weight: 600; margin-bottom: 6px; }

    .used-file-note, .upload-banner, .error-banner {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #ddd; background: #FAFAFA;
      margin-top: 6px;
    }
    .used-file-note { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .upload-banner { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .error-banner { border-color: #e57373; background: #fff5f5; color: #b71c1c; }
  </style>
</head>
<body>
  <div class="shell" id="shell">
    <div class="wrap">
      <h1>Talking Care Navigator</h1>
      <p class="sub">Ask me anything about adult social care in England, including CQC registrations, regulations and guidance, Mental Capacity Act and DoLS queries, best practice advice, auditing, policy queries and more. Always consult your organisations' confidentiality policy.</p>
      <div id="status"></div>
    </div>

    <div class="inputbar" id="inputbar">
      <div class="inputrow">
        <label for="tc-input" class="sr">Message</label>
        <textarea id="tc-input" placeholder="Type your question‚Ä¶ üôÇ"></textarea>
        <button id="tc-ask-stream" class="ui-btn" title="Send" aria-label="Send">‚úàÔ∏è Send</button>
        <button id="tc-clear" class="ui-btn secondary" title="Clear chat" aria-label="Clear">üßΩ Clear</button>
        <button id="attach-btn" class="ui-btn" title="Attach a file" aria-label="Attach">üìé Attach</button>
      </div>
      <div class="attach-row">
        <input id="file-input" type="file" style="display:none" />
        <span id="attach-status" class="attach-status pending" style="display:none;">
          <span class="icon" id="attach-icon">‚åõ</span>
          <span class="fname" id="attach-name"></span>
        </span>
      </div>
    </div>

    <div class="chat-wrap" id="chatwrap">
      <div id="chat" class="chat" aria-live="polite" aria-busy="false"></div>
    </div>
  </div>

  <script>
    if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
    window.addEventListener('DOMContentLoaded', () => {
      window.scrollTo(0, 0);
      setTimeout(() => window.scrollTo(0, 0), 0);
    });
    window.addEventListener('pageshow', (e) => { if (e.persisted) window.scrollTo(0, 0); });
  </script>

  <script type="module">
    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    const purifyUrl = "https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js";
    await import(purifyUrl);

    // Replace with your hosted image if you like
    const ASSISTANT_AVATAR_URL = "https://images.squarespace-cdn.com/content/66d7774bf0cbbe646aefb211/264b05cb-b865-404b-9ac9-cc7f77f15ce9/TRANSPARENCY+crop.png?content-type=image%2Fpng";

    const API_BASE = location.origin.replace(/\/$/, "");
    const $shell   = document.getElementById("shell");
    const $chat    = document.getElementById("chat");
    const $chatwrap= document.getElementById("chatwrap");
    const $inputbar= document.getElementById("inputbar");
    const $in      = document.getElementById("tc-input");
    const $send    = document.getElementById("tc-ask-stream");
    const $clear   = document.getElementById("tc-clear");
    const $status  = document.getElementById("status");

    const $fileInput    = document.getElementById("file-input");
    const $attachBtn    = document.getElementById("attach-btn");
    const $attachStatus = document.getElementById("attach-status");
    const $attachIcon   = document.getElementById("attach-icon");
    const $attachName   = document.getElementById("attach-name");

    const MAX_UPLOAD_BYTES = 20 * 1024 * 1024; // 20 MB

    marked.setOptions({ mangle: false, headerIds: false });
    function setStatus(t){ $status.textContent = t || ""; $chat.setAttribute("aria-busy", t ? "true" : "false"); }

    // ---- Conversation history (client side) ----
    const history = (() => { try { return JSON.parse(sessionStorage.getItem("tc_history") || "[]"); } catch { return []; } })();
    function saveHistory(){ try { sessionStorage.setItem("tc_history", JSON.stringify(history)); } catch {} }
    function clearHistory(){ history.length = 0; saveHistory(); }

    function activateChat(){ if (!$shell.classList.contains("chat-active")) $shell.classList.add("chat-active"); }

    function createMsg(role, headerText, withCopy=false){
      const msg = document.createElement("div");
      msg.className = `msg ${role}`;
      const avatar = document.createElement("div");
      avatar.className = "avatar";

      if (role === "assistant" && ASSISTANT_AVATAR_URL) {
        const img = document.createElement("img");
        img.src = ASSISTANT_AVATAR_URL;
        img.alt = "TCN";
        img.onerror = () => { avatar.textContent = "üìñ"; };
        avatar.appendChild(img);
      } else {
        avatar.textContent = role === "assistant" ? "üìñ" : "üôÇ";
      }

      const bubble = document.createElement("div");
      bubble.className = "bubble";

      const head = document.createElement("div");
      head.className = "bubble-head";
      head.textContent = headerText;

      if (withCopy) {
        const actions = document.createElement("div");
        actions.className = "bubble-actions";
        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn";
        copyBtn.type = "button";
        copyBtn.title = "Copy";
        copyBtn.textContent = "üìã Copy";
        const content = document.createElement("div");
        content.className = "bubble-content";
        copyBtn.addEventListener("click", () => {
          const txt = content.innerText.trim();
          navigator.clipboard.writeText(txt).then(() => {
            copyBtn.textContent = "‚úÖ Copied";
            setTimeout(() => (copyBtn.textContent = "üìã Copy"), 1200);
          });
        });
        actions.appendChild(copyBtn);
        head.appendChild(actions);
        bubble.appendChild(head);
        bubble.appendChild(content);
        msg.appendChild(avatar);
        msg.appendChild(bubble);
        $chat.appendChild(msg);
        $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
        return { msg, content, bubble };
      } else {
        const content = document.createElement("div");
        content.className = "bubble-content";
        bubble.appendChild(head);
        bubble.appendChild(content);
        msg.appendChild(avatar);
        msg.appendChild(bubble);
        $chat.appendChild(msg);
        $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
        return { msg, content, bubble };
      }
    }

    function renderMarkdown(md, el) {
      const html = marked.parse(md || "");
      const safe = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
      el.innerHTML = safe;
      $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
    }

    function appendSources(containerEl, citations) {
      if (!citations || citations.length === 0) return;
      const seenFile = new Set(), seenURL = new Set();
      const files = [], urls = [];
      for (const c of citations) {
        if (c.kind === "file") { if (!seenFile.has(c.id)) { seenFile.add(c.id); files.push(c); } }
        if (c.kind === "web")  { if (!seenURL.has(c.url)) { seenURL.add(c.url); urls.push(c); } }
      }
      if (!files.length && !urls.length) return;
      const src = document.createElement("div");
      src.className = "sources";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = "Sources:";
      src.appendChild(title);
      const list = document.createElement("ul");
      list.style.margin = "0";
      list.style.paddingLeft = "20px";
      [...files, ...urls].forEach((c) => {
        const li = document.createElement("li");
        li.textContent = c.label;
        list.appendChild(li);
      });
      src.appendChild(list);
      containerEl.appendChild(src);
      $inputbar.scrollIntoView({ block: "end", behavior: "smooth" });
    }

    let currentAbort = null;
    let pendingUpload = { file_id: null, filename: "" };

    // --- Upload UI handlers ---
    document.getElementById("attach-btn").addEventListener("click", () => $fileInput.click());

    $fileInput.addEventListener("change", async () => {
      const file = $fileInput.files?.[0];
      if (!file) return;

      if (file.size > 20 * 1024 * 1024) {
        $attachStatus.style.display = "inline-flex";
        $attachStatus.className = "attach-status error";
        $attachIcon.textContent = "‚ö†Ô∏è";
        $attachName.textContent = "File too large (20 MB max)";
        pendingUpload = { file_id: null, filename: "" };
        return;
      }

      $attachStatus.style.display = "inline-flex";
      $attachStatus.className = "attach-status pending";
      $attachIcon.textContent = "‚åõ";
      $attachName.textContent = file.name.length > 36 ? file.name.slice(0, 33) + "..." : file.name;

      try {
        const fd = new FormData();
        fd.append("file", file);
        const r = await fetch(`${API_BASE}/api/upload`, { method: "POST", body: fd });
        const data = await r.json().catch(() => ({}));
        if (!r.ok || !data.ok || !data.file_id) throw new Error(data?.error || "Upload failed");

        pendingUpload = { file_id: data.file_id, filename: file.name };
        if (data.processed) {
          $attachStatus.className = "attach-status ok";
          $attachIcon.textContent = "‚úÖ";
        } else {
          $attachStatus.className = "attach-status pending";
          $attachIcon.textContent = "‚åõ";
          $attachName.textContent = "Processing‚Ä¶ try your question in a moment";
        }
        $attachName.textContent = (file.name.length > 36 ? file.name.slice(0,33) + "..." : file.name);
      } catch (e) {
        $attachStatus.className = "attach-status error";
        $attachIcon.textContent = "‚ö†Ô∏è";
        $attachName.textContent = e?.message || "Upload failed";
        pendingUpload = { file_id: null, filename: "" };
      }
    });

    // --- SSE streaming ---
    async function askStream(prompt) {
      activateChat();

      history.push({ role: "user", content: prompt });
      saveHistory();

      const userMsg = createMsg("user", "You");
      userMsg.content.textContent = prompt;

      let usedFileId = null;
      let uploadTurn = false;
      if (pendingUpload.file_id) {
        usedFileId = pendingUpload.file_id;
        uploadTurn = true;
        const used = document.createElement("div");
        used.className = "used-file-note";
        used.innerHTML = `‚úÖ Using: <strong>${(pendingUpload.filename.length > 36 ? pendingUpload.filename.slice(0,33) + "..." : pendingUpload.filename)}</strong>`;
        userMsg.bubble.appendChild(used);

        pendingUpload = { file_id: null, filename: "" };
        $fileInput.value = "";
        $attachStatus.style.display = "none";
        $attachStatus.className = "attach-status pending";
        $attachIcon.textContent = "‚åõ";
        $attachName.textContent = "";
      }

      const { content: aContent, bubble: aBubble } = createMsg("assistant", "Talking Care Navigator", true);
      aContent.innerHTML = `<em>Thinking‚Ä¶ ‚è≥</em>`;

      if (uploadTurn) {
        const banner = document.createElement("div");
        banner.className = "upload-banner";
        banner.textContent = "Answer based only on your attached document.";
        aBubble.appendChild(banner);
      }

      let buffer = "";
      let started = false;
      let firstDeltaSeen = false;
      let mdAccum = "";
      const citations = [];
      let sourcesAppended = false;
      let assistantTurnSaved = false;

      setStatus("Thinking‚Ä¶ ‚è≥");
      const ac = new AbortController();
      currentAbort = ac;

      const watchdog = setTimeout(() => {
        if (!started) {
          aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è No stream started ‚Äî check connectivity or CORS settings.</span>`;
          setStatus("");
        }
      }, 10000);

      const body = { userMessage: prompt, history };
      if (usedFileId) body.upload_file_id = usedFileId;

      let r;
      try {
        r = await fetch(`${API_BASE}/api/assistant?stream=on`, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "text/event-stream" },
          body: JSON.stringify(body),
          signal: ac.signal
        });
      } catch (e) {
        clearTimeout(watchdog);
        aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è Request failed: ${escapeHtml(e?.message || e)}</span>`;
        setStatus("");
        currentAbort = null;
        return;
      }

      if (!r.ok || !r.body) {
        clearTimeout(watchdog);
        let err = `HTTP ${r.status}`;
        try { err += ` ${await r.text()}`; } catch {}
        aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è Stream failed: ${escapeHtml(err)}</span>`;
        setStatus("");
        currentAbort = null;
        return;
      }

      const reader = r.body.getReader();
      const decoder = new TextDecoder("utf-8");

      const flushBlocks = (chunk) => {
        buffer += chunk;
        const blocks = buffer.split(/\n\n/);
        buffer = blocks.pop();
        for (const block of blocks) {
          const lines = block.split(/\n/);
          let event = "message";
          const dataLines = [];
          for (const line of lines) {
            if (!line) continue;
            if (line.startsWith(":")) continue;
            if (line.startsWith("event:")) { event = line.slice(6).trim(); continue; }
            if (line.startsWith("data:"))  { dataLines.push(line.slice(5).trim()); continue; }
          }
          const raw = dataLines.join("\n");
          handleEvent(event, raw);
        }
      };

      function handleEvent(event, raw) {
        if (event === "start") return;

        if (event === "info") {
          try {
            const obj = JSON.parse(raw);
            if (obj?.note === "temp_vector_store_failed") {
              const errMsg = (obj?.error || "We couldn't prepare your document for search. Please try uploading again.");
              const banner = document.createElement("div");
              banner.className = "error-banner";
              banner.textContent = `‚ö†Ô∏è ${errMsg}`;
              aBubble.appendChild(banner);
              if (currentAbort) { try { currentAbort.abort(); } catch {} currentAbort = null; }
              setStatus("");
            }
          } catch {}
          return;
        }

        if (event === "error") {
          try {
            const obj = JSON.parse(raw);
            aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è ${escapeHtml(JSON.stringify(obj))}</span>`;
          } catch {
            aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è ${escapeHtml(raw)}</span>`;
          }
          setStatus("");
          return;
        }

        if (event === "done" || event === "response.completed") {
          setStatus("");
          if (!sourcesAppended) {
            appendSources(aContent, citations);
            sourcesAppended = true;
          }
          if (!assistantTurnSaved) {
            const finalText = stripInlineSources(mdAccum).trim();
            if (finalText) {
              history.push({ role: "assistant", content: finalText });
              saveHistory();
            }
            assistantTurnSaved = true;
          }
          return;
        }

        if (event.endsWith(".delta")) {
          let d;
          try { d = JSON.parse(raw); } catch { d = null; }
          const deltaText =
            (d && typeof d.delta === "string") ? d.delta :
            (d && d.delta && Array.isArray(d.delta.content))
              ? d.delta.content.map(c => (c.text && (c.type?.includes("output_text"))) ? c.text : "").join("")
              : (typeof d?.text_delta === "string" ? d.text_delta : "");

          if (deltaText) {
            if (!firstDeltaSeen) { firstDeltaSeen = true; setStatus(""); }
            const cleaned = sanitizeBodyDelta(deltaText);
            mdAccum += cleaned;
            renderMarkdown(mdAccum, aContent);
          }
          return;
        }

        if (event.includes("annotation") || event.includes("citation")) {
          let a;
          try {
            const obj = JSON.parse(raw);
            a = obj?.annotation || obj?.data || obj;
          } catch { a = null; }
          if (!a) return;
          if (a.type === "file_citation" && a.file_id) {
            citations.push({ kind: "file", id: a.file_id, label: a.filename || a.file_id });
          } else if ((a.type === "web_citation" || a.url) && a.url) {
            citations.push({ kind: "web", url: a.url, label: a.title || a.url });
          }
        }
      }

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          if (chunk && !started) { started = true; clearTimeout(watchdog); }
          flushBlocks(chunk);
        }
      } catch (e) {
        aContent.insertAdjacentHTML("beforeend", `<p class="error-banner">‚ö†Ô∏è Stream error: ${escapeHtml(e?.message || String(e))}</p>`);
      } finally {
        currentAbort = null;
        setStatus("");
      }
    }

    function sanitizeBodyDelta(s) {
      if (!s) return s;
      s = s.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, "$1");
      s = s.replace(/https?:\/\/\S+/g, "");
      s = s.replace(/\s?\[\d+\]/g, "");
      s = s.replace(/\n?^\s*Sources?:[\s\S]*$/im, "");
      return s;
    }
    function stripInlineSources(s) {
      if (!s) return s;
      return s.replace(/\n?^\s*Sources?:[\s\S]*$/im, "");
    }
    function escapeHtml(str) {
      return (str || "").replace(/[&<>"']/g, (ch) => ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;" }[ch]));
    }

    // Events
    document.getElementById("tc-ask-stream").addEventListener("click", () => {
      const p = ($in.value || "").trim();
      if (!p) return;
      askStream(p);
      $in.value = "";
    });
    $in.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); document.getElementById("tc-ask-stream").click(); }
    });
    document.getElementById("tc-clear").addEventListener("click", () => {
      if (currentAbort) { try { currentAbort.abort(); } catch {} currentAbort = null; }
      $chat.innerHTML = "";
      $in.value = "";
      setStatus("");
      clearHistory();
      $shell.classList.remove("chat-active");
      pendingUpload = { file_id: null, filename: "" };
      $fileInput.value = "";
      $attachStatus.style.display = "none";
      $attachStatus.className = "attach-status pending";
      $attachIcon.textContent = "‚åõ";
      $attachName.textContent = "";
    });
  </script>
</body>
</html>
