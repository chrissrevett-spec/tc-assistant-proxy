<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Talking Care Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; scrollbar-color: #ccc #FAFAFA; scrollbar-width: thin; }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 10px; }
    html::-webkit-scrollbar-track, body::-webkit-scrollbar-track { background: #FAFAFA; }
    html::-webkit-scrollbar-thumb, body::-webkit-scrollbar-thumb { background: #ccc; border-radius: 8px; }
    html:hover::-webkit-scrollbar-thumb, body:hover::-webkit-scrollbar-thumb { background: #b3b3b3; }

    html, body { height: 100%; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0; padding: 0; background: #fff; color: #000;
      display: flex; flex-direction: column; min-height: 100dvh;
    }

    .shell { width: 100%; max-width: 980px; margin: 0 auto; flex: 1 1 auto; display: flex; flex-direction: column; }

    .wrap { padding: 16px 16px 8px; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .sub { margin: 0; font-size: 14px; color: #000; opacity: .9; }
    #status { font-size: 12px; color: #555; min-height: 18px; margin-top: 6px; }

    .inputbar {
      background: #fff;
      padding: 8px 16px 12px;
      border-top: 1px solid #f0f0f0;
      border-bottom: 1px solid #f0f0f0;
      order: 2;
      position: sticky; bottom: 0; z-index: 2; /* keep controls visible */
    }

    .inputrow { display: flex; gap: 8px; align-items: flex-start; flex-wrap: nowrap; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }

    .sr { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }

    textarea {
      flex: 1 1 auto; min-height: 48px; max-height: 160px; resize: vertical;
      padding: 10px; font: inherit; background: #FAFAFA; color: #000;
      border: 1px solid #ddd; border-radius: 10px; transition: background .2s, border-color .2s, box-shadow .2s;
      scrollbar-width: thin; scrollbar-color: #ccc #FAFAFA; box-sizing: border-box;
    }
    textarea:focus { background: #f7f7f7; border-color: #ccc; outline: none; box-shadow: 0 0 0 2px rgba(0,0,0,0.04); }

    .ui-btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 8px;
      height: 40px; padding: 0 14px; cursor: pointer; border-radius: 10px; border: 1px solid #ddd;
      background: #FAFAFA; color: #333; font-size: 14px; line-height: 1; letter-spacing: .2px;
      transition: background .2s, color .2s, border-color .2s, box-shadow .2s, transform .08s ease;
      white-space: nowrap; user-select: none; flex: 0 0 auto;
    }
    .ui-btn:hover { background: #f0f0f0; border-color: #ccc; }
    .ui-btn.secondary { background: #FAFAFA; color: #333; border-color: #ddd; }
    .ui-btn.secondary:hover { background: #f0f0f0; border-color: #ccc; } /* fix: clear hover/darken */
    .ui-btn.danger { border-color: #f2b8b8; color: #b40000; }
    .ui-btn:disabled { opacity: .5; cursor: not-allowed; }

    /* slightly larger emojis in buttons */
    .ui-btn .emoji { font-size: 18px; line-height: 1; display: inline-block; }

    /* hover/click animations */
    @keyframes hop { 0% { transform: translateY(0); } 50% { transform: translateY(-3px); } 100% { transform: translateY(0); } }
    @keyframes spinOnce { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* Hop while hovered */
    #attach-btn:hover .clip-emoji,
    #tc-ask-stream:hover .send-emoji,
    #tc-clear:hover .trash-emoji { animation: hop 600ms ease-in-out infinite; }

    /* Spin once (added via JS) */
    .spin-once { animation: spinOnce 500ms ease-in-out 1; }

    @media (max-width: 540px) {
      .inputrow { flex-wrap: wrap; }
      .inputrow textarea { flex: 1 1 100%; width: 100%; }
      .controls { gap: 6px; }
      .ui-btn { height: 38px; }
    }

    .attach-row { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
    .attach-status {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #ddd; background: #FAFAFA;
      max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .attach-status .fname { max-width: 36ch; overflow: hidden; text-overflow: ellipsis; }
    .attach-status.ok { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .attach-status.pending { border-color: #ddd; background: #FAFAFA; color: #333; }
    .attach-status.error { border-color: #e57373; background: #fff5f5; color: #b71c1c; }
    .attach-status .icon { font-size: 14px; }

    /* Drag & drop highlight */
    .drop-active textarea { border-color: #9ad0ff; box-shadow: 0 0 0 3px rgba(0,140,255,0.12); background: #f5fbff; }

    .chat-wrap { display: none; }
    .chat {
      border: 1px solid #eee; background: #fff; border-radius: 12px;
      padding: 12px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.03), 0 12px 24px rgba(0,0,0,.06);
      margin: 12px 16px 0;
    }
    .chat-active .chat-wrap { display: block; order: 2; }
    .chat-active .inputbar { order: 3; border-top: none; }

    .msg { display: flex; gap: 10px; margin: 10px 0; align-items: flex-start; }
    .msg.assistant { flex-direction: row; }
    .msg.user { flex-direction: row-reverse; }

    .avatar {
      flex: 0 0 32px; height: 32px; width: 32px; border-radius: 50%;
      display: grid; place-items: center; background: #FAFAFA; border: 1px solid #eee;
      font-size: 18px; line-height: 1; overflow: hidden;
    }
    .avatar img { width: 100%; height: 100%; object-fit: cover; border-radius: 50%; }

    .bubble {
      max-width: 80%;
      background: #FAFAFA; color: #000;
      border: 1px solid #eee; border-radius: 14px;
      padding: 10px 12px; position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,.04);
      overflow: hidden;
    }
    .msg.user .bubble { background: #FFF; border-color: #ddd; }

    .bubble-head {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
      font-weight: 600; font-size: 13px; color: #111;
    }
    .bubble-meta { margin-left: auto; font-weight: 400; font-size: 11px; color: #777; }

    .bubble-actions { margin-left: 8px; display: flex; gap: 6px; }
    .copy-btn {
      border: 1px solid #ddd; background: #FAFAFA; color: #333; border-radius: 6px;
      font-size: 12px; padding: 2px 6px; cursor: pointer;
    }
    .copy-btn:hover { background: #f0f0f0; }

    .used-file-note, .upload-banner, .error-banner {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #ddd; background: #FAFAFA;
      margin-top: 6px;
    }
    .used-file-note { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .upload-banner { border-color: #4caf50; background: #f2fff2; color: #256f2a; }
    .error-banner { border-color: #e57373; background: #fff5f5; color: #b71c1c; }

    /* Assistant ‚ÄúUsing: ‚Ä¶‚Äù chip */
    .using-chip {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #cde6cd; background: #f6fff6; color: #215c21;
      margin: 0 0 8px; max-width: 100%;
    }
    .using-chip .fname { max-width: 40ch; overflow: hidden; text-overflow: ellipsis; }

    .bubble-content { font-size: 14px; line-height: 1.5; }
    .bubble-content p { margin: 0 0 8px; }
    .bubble-content code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f5f5f5; padding: 1px 4px; border-radius: 4px; border: 1px solid #eee; }
    .bubble-content pre { background: #f5f5f5; padding: 8px; border-radius: 8px; overflow-x: auto; border: 1px solid #eee; }
    .bubble-content h1, .bubble-content h2, .bubble-content h3 { margin: 12px 0 6px; }
    .bubble-content ul, .bubble-content ol { margin: 8px 0 8px 20px; }
    .bubble-content blockquote { margin: 8px 0; padding: 8px 12px; background: #f7f7f7; border-left: 3px solid #ddd; border-radius: 6px; }

    .bubble-content table { width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 14px; }
    .bubble-content th, .bubble-content td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; vertical-align: top; }
    .bubble-content th { background: #f7f7f7; }
    .bubble-content tr:nth-child(even) td { background: #fcfcfc; }

    .sources { margin-top: 10px; padding-top: 8px; border-top: 1px dashed #e5e5e5; font-size: 13px; color: #444; }
    .sources .title { font-weight: 600; margin-bottom: 6px; }
    .sources a { color: inherit; text-decoration: underline; }
    .sources a:focus { outline: 2px solid #ddd; outline-offset: 2px; }
  </style>
</head>
<body>
  <div class="shell" id="shell">
    <div class="wrap">
      <h1>Talking Care Navigator</h1>
      <p class="sub">Ask me anything about adult social care in England, including CQC registrations, regulations and guidance, Mental Capacity Act and DoLS queries, best practice advice, auditing, policy queries and more. Always consult your organisations' confidentiality policy. Talking Care Navigator may make a mistake. Always check important info.</p>
      <div id="status" role="status" aria-live="polite"></div>
    </div>

    <div class="inputbar" id="inputbar">
      <div class="inputrow" id="dropzone">
        <label for="tc-input" class="sr">Message</label>
        <textarea id="tc-input" placeholder="Type your question‚Ä¶ üôÇ" aria-label="Message"></textarea>

        <div class="controls" aria-label="Controls">
          <button id="tc-ask-stream" class="ui-btn" title="Send" aria-label="Send">
            <span class="emoji send-emoji">‚úàÔ∏è</span> Send
          </button>
          <button id="tc-stop" class="ui-btn danger" title="Stop response" aria-label="Stop" disabled>
            <span class="emoji">‚èπ</span> Stop
          </button>
          <button id="tc-clear" class="ui-btn secondary" title="Clear chat" aria-label="Clear">
            <span class="emoji trash-emoji">üóëÔ∏è</span> Clear
          </button>
          <button id="attach-btn" class="ui-btn" title="Attach a file" aria-label="Attach">
            <span class="emoji clip-emoji">üìé</span> Attach
          </button>
        </div>
      </div>

      <div class="attach-row">
        <input id="file-input" type="file" style="display:none" />
        <span id="attach-status" class="attach-status pending" style="display:none;">
          <span class="icon" id="attach-icon">‚åõ</span>
          <span class="fname" id="attach-name"></span>
        </span>
      </div>
    </div>

    <div class="chat-wrap" id="chatwrap">
      <div id="chat" class="chat" aria-live="polite" aria-busy="false"></div>
    </div>
  </div>

  <script>
    if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
    window.addEventListener('DOMContentLoaded', () => { window.scrollTo(0, 0); setTimeout(() => window.scrollTo(0, 0), 0); });
    window.addEventListener('pageshow', (e) => { if (e.persisted) window.scrollTo(0, 0); });
  </script>

  <script type="module">
    import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
    const purifyUrl = "https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js";
    await import(purifyUrl);

    marked.setOptions({ gfm: true, breaks: true, mangle: false, headerIds: false });

    const ASSISTANT_AVATAR_URL = "https://images.squarespace-cdn.com/content/66d7774bf0cbbe646aefb211/264b05cb-b865-404b-9ac9-cc7f77f15ce9/TRANSPARENCY+crop.png?content-type=image%2Fpng";
    const API_BASE = location.origin.replace(/\/$/, "");

    const $shell   = document.getElementById("shell");
    const $chat    = document.getElementById("chat");
    const $chatwrap= document.getElementById("chatwrap");
    const $inputbar= document.getElementById("inputbar");
    const $drop    = document.getElementById("dropzone");
    const $in      = document.getElementById("tc-input");
    const $send    = document.getElementById("tc-ask-stream");
    const $stop    = document.getElementById("tc-stop");
    const $clear   = document.getElementById("tc-clear");
    const $status  = document.getElementById("status");

    const $fileInput    = document.getElementById("file-input");
    const $attachBtn    = document.getElementById("attach-btn");
    const $attachStatus = document.getElementById("attach-status");
    const $attachIcon   = document.getElementById("attach-icon");
    const $attachName   = document.getElementById("attach-name");

    const MAX_UPLOAD_BYTES = 20 * 1024 * 1024; // 20 MB
    const SOURCE_TITLE = "Sources:";

    function setStatus(t){ $status.textContent = t || ""; $chat.setAttribute("aria-busy", t ? "true" : "false"); }
    function activateChat(){ if (!$shell.classList.contains("chat-active")) $shell.classList.add("chat-active"); }
    function scrollToBottom(){ requestAnimationFrame(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' })); }

    // Conversation history (client side)
    const history = (() => { try { return JSON.parse(sessionStorage.getItem("tc_history") || "[]"); } catch { return []; } })();
    function saveHistory(){ try { sessionStorage.setItem("tc_history", JSON.stringify(history)); } catch {} }
    function clearHistory(){ history.length = 0; saveHistory(); }

    function timeStamp() {
      const d = new Date();
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function createMsg(role, headerText, withCopy=false){
      const msg = document.createElement("div");
      msg.className = `msg ${role}`;
      const avatar = document.createElement("div"); avatar.className = "avatar";

      if (role === "assistant" && ASSISTANT_AVATAR_URL) {
        const img = document.createElement("img");
        img.src = ASSISTANT_AVATAR_URL; img.alt = "TCN";
        img.onerror = () => { avatar.textContent = "üìñ"; };
        avatar.appendChild(img);
      } else {
        avatar.textContent = role === "assistant" ? "üìñ" : "üôÇ";
      }

      const bubble = document.createElement("div"); bubble.className = "bubble";
      const head = document.createElement("div"); head.className = "bubble-head";
      const title = document.createElement("div"); title.textContent = headerText;
      const meta = document.createElement("div"); meta.className = "bubble-meta"; meta.textContent = timeStamp();
      head.appendChild(title); head.appendChild(meta);

      const content = document.createElement("div"); content.className = "bubble-content";

      if (withCopy) {
        const actions = document.createElement("div"); actions.className = "bubble-actions";
        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-btn"; copyBtn.type = "button"; copyBtn.title = "Copy"; copyBtn.textContent = "üìã Copy";
        copyBtn.addEventListener("click", () => {
          const txt = content.innerText.trim();
          navigator.clipboard.writeText(txt).then(() => {
            copyBtn.textContent = "‚úÖ Copied"; setTimeout(() => (copyBtn.textContent = "üìã Copy"), 1200);
          });
        });
        head.appendChild(actions); actions.appendChild(copyBtn);
      }

      bubble.appendChild(head);

      // slot for ‚ÄúUsing: ‚Ä¶‚Äù chip (assistant turns)
      const usingSlot = document.createElement("div");
      bubble.appendChild(usingSlot);

      bubble.appendChild(content);
      msg.appendChild(avatar); msg.appendChild(bubble);
      $chat.appendChild(msg);
      scrollToBottom(); // fix auto-scroll
      return { msg, content, bubble, usingSlot };
    }

    function renderMarkdown(md, el) {
      const html = marked.parse(md || "");
      const safe = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
      el.innerHTML = safe;
      scrollToBottom(); // fix auto-scroll
    }

    function appendSources(containerEl, citations) {
      if (!citations || citations.length === 0) return;
      const seenFile = new Set(), seenURL = new Set();
      const files = [], urls = [];
      for (const c of citations) {
        if (c.kind === "file") { if (!seenFile.has(c.id)) { seenFile.add(c.id); files.push(c); } }
        if (c.kind === "web")  { if (!seenURL.has(c.url)) { seenURL.add(c.url); urls.push(c); } }
      }
      if (!files.length && !urls.length) return;

      // avoid duplicate Sources blocks
      if (containerEl.querySelector(".sources")) return;

      const src = document.createElement("div");
      src.className = "sources";
      const title = document.createElement("div");
      title.className = "title";
      title.textContent = SOURCE_TITLE;
      src.appendChild(title);

      const list = document.createElement("ul");
      list.style.margin = "0"; list.style.paddingLeft = "20px";

      files.forEach((c) => {
        const li = document.createElement("li");
        li.textContent = c.label || c.id;
        list.appendChild(li);
      });
      urls.forEach((c) => {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = c.url; a.target = "_blank"; a.rel = "noopener noreferrer";
        a.textContent = c.label || c.url;
        li.appendChild(a);
        list.appendChild(li);
      });

      src.appendChild(list);
      containerEl.appendChild(src);
      scrollToBottom(); // fix auto-scroll
    }

    let currentAbort = null;
    let pendingUpload = { file_id: null, filename: "" };
    let lastUsedAttachmentName = "";

    // Upload UI (click)
    $attachBtn.addEventListener("click", () => {
      // spin on click (once)
      const icon = $attachBtn.querySelector('.clip-emoji');
      if (icon) {
        icon.classList.remove('spin-once');
        void icon.offsetWidth; // restart animation
        icon.classList.add('spin-once');
      }
      $fileInput.click();
    });

    // Drag & drop
    ["dragenter","dragover"].forEach(evt => {
      $drop.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); $inputbar.classList.add("drop-active"); });
    });
    ["dragleave","drop"].forEach(evt => {
      $drop.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); $inputbar.classList.remove("drop-active"); });
    });
    $drop.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      if (!dt || !dt.files || !dt.files.length) return;
      handleFiles(dt.files);
    });

    // File input change
    $fileInput.addEventListener("change", () => handleFiles($fileInput.files));

    async function handleFiles(fileList) {
      const file = fileList?.[0];
      if (!file) return;

      if (file.size > MAX_UPLOAD_BYTES) {
        $attachStatus.style.display = "inline-flex";
        $attachStatus.className = "attach-status error";
        $attachIcon.textContent = "‚ö†Ô∏è";
        $attachName.textContent = "File too large (20 MB max)";
        pendingUpload = { file_id: null, filename: "" };
        return;
      }

      $attachStatus.style.display = "inline-flex";
      $attachStatus.className = "attach-status pending";
      $attachIcon.textContent = "‚åõ";
      $attachName.textContent = file.name.length > 36 ? file.name.slice(0, 33) + "..." : file.name;

      try {
        const fd = new FormData(); fd.append("file", file);
        const r = await fetch(`${API_BASE}/api/upload`, { method: "POST", body: fd });
        const data = await r.json().catch(() => ({}));
        if (!r.ok || !data.ok || !data.file_id) {
          const msg = (data && (data.error || data.message)) || "";
          if (String(msg).includes("File type not supported")) {
            throw new Error("File type not supported. Please upload a different file.");
          }
          throw new Error(msg || "Upload failed");
        }

        pendingUpload = { file_id: data.file_id, filename: file.name };
        if (data.processed) {
          $attachStatus.className = "attach-status ok"; $attachIcon.textContent = "‚úÖ";
        } else {
          $attachStatus.className = "attach-status pending";
          $attachIcon.textContent = "‚åõ";
          $attachName.textContent = (file.name.length > 36 ? file.name.slice(0,33) + "..." : file.name) + " ‚Äî processing‚Ä¶";
        }
      } catch (e) {
        $attachStatus.className = "attach-status error";
        $attachIcon.textContent = "‚ö†Ô∏è";
        $attachName.textContent = e?.message || "Upload failed";
        pendingUpload = { file_id: null, filename: "" };
      }
    }

    // SSE ask
    async function askStream(prompt) {
      activateChat();

      history.push({ role: "user", content: prompt });
      saveHistory();

      const userMsg = createMsg("user", "You");
      userMsg.content.textContent = prompt;

      // Prepare request body (attach file if present for THIS turn)
      const body = { userMessage: prompt, history };
      let uploadTurn = false;
      lastUsedAttachmentName = "";

      if (pendingUpload.file_id) {
        body.upload_file_id = pendingUpload.file_id;
        uploadTurn = true;
        lastUsedAttachmentName = pendingUpload.filename || "";

        // Show a chip in the user bubble
        const used = document.createElement("div");
        used.className = "used-file-note";
        const shortName = lastUsedAttachmentName.length > 36 ? lastUsedAttachmentName.slice(0,33) + "..." : lastUsedAttachmentName;
        used.innerHTML = `‚úÖ Using: <strong>${shortName}</strong>`;
        userMsg.bubble.appendChild(used);

        // Clear selection after consuming it
        pendingUpload = { file_id: null, filename: "" };
        $fileInput.value = "";
        $attachStatus.style.display = "none";
        $attachStatus.className = "attach-status pending";
        $attachIcon.textContent = "‚åõ";
        $attachName.textContent = "";
      }

      const { content: aContent, bubble: aBubble, usingSlot } = createMsg("assistant", "Talking Care Navigator", true);
      aContent.innerHTML = `<em>Thinking‚Ä¶ ‚è≥</em>`;

      // Assistant ‚ÄúUsing: ‚Ä¶‚Äù chip
      if (uploadTurn && lastUsedAttachmentName) {
        const chip = document.createElement("div");
        chip.className = "using-chip";
        chip.innerHTML = `‚úÖ <span>Using:</span> <span class="fname" title="${escapeHtml(lastUsedAttachmentName)}">${escapeHtml(lastUsedAttachmentName)}</span>`;
        usingSlot.appendChild(chip);
      }

      // Assistant-side banner confirming scope for upload turns
      if (uploadTurn) {
        const banner = document.createElement("div");
        banner.className = "upload-banner";
        banner.textContent = "Answer based only on the attached document.";
        aBubble.appendChild(banner);
      }

      let mdAccum = "";
      const citations = [];
      let sourcesAppended = false;
      let assistantTurnSaved = false;

      setStatus("Thinking‚Ä¶ ‚è≥");
      const ac = new AbortController(); currentAbort = ac;
      $stop.disabled = false;

      let started = false;
      const watchdog = setTimeout(() => {
        if (!started) {
          aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è No stream started ‚Äî check connectivity or CORS settings.</span>`;
          setStatus("");
          $stop.disabled = true; currentAbort = null;
        }
      }, 10000);

      let r;
      try {
        r = await fetch(`${API_BASE}/api/assistant?stream=on`, {
          method: "POST",
          headers: { "Content-Type": "application/json", "Accept": "text/event-stream" },
          body: JSON.stringify(body),
          signal: ac.signal
        });
      } catch (e) {
        clearTimeout(watchdog);
        aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è Request failed: ${escapeHtml(e?.message || e)}</span>`;
        setStatus(""); currentAbort = null; $stop.disabled = true; return;
      }

      if (!r.ok || !r.body) {
        clearTimeout(watchdog);
        let errText = "";
        try { errText = await r.text(); } catch {}
        const friendly = (errText && errText.includes("File type not supported")) ? "File type not supported. Please upload a different file." : `HTTP ${r.status}${errText ? ` ${escapeHtml(errText)}` : ""}`;
        aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è ${friendly}</span>`;
        setStatus(""); currentAbort = null; $stop.disabled = true; return;
      }

      const reader = r.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let buffer = "";

      const flushBlocks = (chunk) => {
        buffer += chunk;
        const blocks = buffer.split(/\n\n/);
        buffer = blocks.pop();
        for (const block of blocks) {
          const lines = block.split(/\n/);
          let event = "message";
          const dataLines = [];
          for (const line of lines) {
            if (!line) continue;
            if (line.startsWith(":")) continue;
            if (line.startsWith("event:")) { event = line.slice(6).trim(); continue; }
            if (line.startsWith("data:"))  { dataLines.push(line.slice(5).trim()); continue; }
          }
          const raw = dataLines.join("\n");
          handleEvent(event, raw);
        }
      };

      function handleEvent(event, raw) {
        if (event === "start") return;

        if (event === "info") {
          // purely informational
          return;
        }

        if (event === "error") {
          try {
            const obj = JSON.parse(raw);
            const msg = (obj && (obj.message || obj.error || "")) || "";
            const friendly = String(msg).includes("File type not supported")
              ? "File type not supported. Please upload a different file."
              : JSON.stringify(obj);
            aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è ${escapeHtml(friendly)}</span>`;
          } catch {
            const friendly = String(raw).includes("File type not supported")
              ? "File type not supported. Please upload a different file."
              : raw;
            aContent.innerHTML = `<span class="error-banner">‚ö†Ô∏è ${escapeHtml(friendly)}</span>`;
          }
          setStatus(""); $stop.disabled = true; return;
        }

        if (event === "done" || event === "response.completed") {
          setStatus("");
          renderMarkdown(mdAccum, aContent);
          if (!sourcesAppended && citations.length) {
            appendSources(aContent, citations);
            sourcesAppended = true;
          }
          if (!assistantTurnSaved) {
            history.push({ role: "assistant", content: mdAccum.trim() });
            saveHistory();
            assistantTurnSaved = true;
          }
          $stop.disabled = true; currentAbort = null;
          return;
        }

        // Text deltas (append raw, no rewrites)
        if (event.endsWith(".delta")) {
          let d; try { d = JSON.parse(raw); } catch { d = null; }

          /* ---- ADDED: harvest embedded annotations/citations from deltas ---- */
          const harvest = (annos) => {
            if (!Array.isArray(annos)) return;
            for (const a of annos) {
              if (a?.type === "file_citation" && a.file_id) {
                citations.push({ kind: "file", id: a.file_id, label: a.filename || a.file_id });
              } else if (a?.url) {
                citations.push({ kind: "web", url: a.url, label: a.title || a.url });
              }
            }
          };
          if (d?.annotations) harvest(d.annotations);
          if (d?.delta?.annotations) harvest(d.delta.annotations);
          if (Array.isArray(d?.delta?.content)) {
            for (const part of d.delta.content) {
              if (Array.isArray(part?.annotations)) harvest(part.annotations);
            }
          }
          /* ---- END ADDED ---- */

          const deltaText =
            (d && typeof d.delta === "string") ? d.delta :
            (d && d.delta && Array.isArray(d.delta.content))
              ? d.delta.content.map(c => (c.text && (c.type?.includes("output_text"))) ? c.text : "").join("")
              : (typeof d?.text_delta === "string" ? d.text_delta : "");

          if (deltaText) {
            if (!started) { started = true; clearTimeout(watchdog); }
            mdAccum += deltaText;
            renderMarkdown(mdAccum, aContent);
          }
          return;
        }

        // Optional: capture citations if the API emits them as dedicated events
        if (event.includes("annotation") || event.includes("citation")) {
          let a;
          try { const obj = JSON.parse(raw); a = obj?.annotation || obj?.data || obj; } catch { a = null; }
          if (!a) return;
          if (a.type === "file_citation" && a.file_id) {
            citations.push({ kind: "file", id: a.file_id, label: a.filename || a.file_id });
          } else if ((a.type === "web_citation" || a.url) && a.url) {
            citations.push({ kind: "web", url: a.url, label: a.title || a.url });
          }
        }
      }

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          if (chunk && !started) { started = true; clearTimeout(watchdog); }
          flushBlocks(chunk);
        }
      } catch (e) {
        aContent.insertAdjacentHTML("beforeend", `<p class="error-banner">‚ö†Ô∏è Stream error: ${escapeHtml(e?.message || String(e))}</p>`);
      } finally {
        clearTimeout(watchdog);
        currentAbort = null;
        $stop.disabled = true;
        setStatus("");
      }
    }

    function escapeHtml(str) {
      return (str || "").replace(/[&<>"']/g, (ch) => ({ "&":"&amp;","<":"&lt;","&gt;":">&gt;","\"":"&quot;","'":"&#039;" }[ch]));
    }

    // Events
    $send.addEventListener("click", () => {
      const icon = $send.querySelector('.send-emoji');
      if (icon) { icon.classList.remove('spin-once'); void icon.offsetWidth; icon.classList.add('spin-once'); }
      const p = ($in.value || "").trim();
      if (!p) return;
      askStream(p);
      $in.value = "";
    });
    $in.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); $send.click(); }
    });
    $clear.addEventListener("click", () => {
      const icon = $clear.querySelector('.trash-emoji');
      if (icon) { icon.classList.remove('spin-once'); void icon.offsetWidth; icon.classList.add('spin-once'); }
      if (currentAbort) { try { currentAbort.abort(); } catch {} currentAbort = null; }
      $chat.innerHTML = "";
      $in.value = "";
      setStatus("");
      clearHistory();
      $shell.classList.remove("chat-active");
      pendingUpload = { file_id: null, filename: "" };
      $fileInput.value = "";
      $attachStatus.style.display = "none";
      $attachStatus.className = "attach-status pending";
      $attachIcon.textContent = "‚åõ";
      $attachName.textContent = "";
      lastUsedAttachmentName = "";
      scrollToBottom();
    });
    $stop.addEventListener("click", () => {
      if (currentAbort) { try { currentAbort.abort(); } catch {} }
      currentAbort = null;
      $stop.disabled = true;
      setStatus("");
    });
  </script>
</body>
</html>
